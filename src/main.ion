const
    range = (n) -> [i for let i = 0; i < n; i++]
    enableBit(n, i) -> n | (1 << i)
    disableBit(n, i) -> n & ~(1 << i)
    setBit(n, i, v) -> v is 0 ? disableBit(n, i) : enableBit(n, i)
    nmask(n) -> ~((~0) << n)
    bitSum(n, upto) ->
        let sum = 0
        for let i = 0; i < upto; i++
            sum += (n >> i) & 1
        return sum
    firstOne(n, upto) ->
        for let i = 0; i < upto; i++
            if ((n >> i) & 1) is 1
                return i
    allOnes(n, upto) ->
        return []
            for let i = 0; i < upto; i++
                if ((n >> i) & 1) is 1
                    i

export class Board
    constructor: (blockWidth) ->
        @blockWidth = blockWidth
        @boardWidth = blockWidth * blockWidth
        @fullDomain = nmask(@boardWidth)
        @area = @boardWidth * @boardWidth
        @cells = [@fullDomain for i in range(@area)]
        @undoStack = []
        @netDomain = @area * @boardWidth

    properties:
        pushUndo: (undo) ->
            @undoStack.push(undo)
        startUndoGroup: ->
            @undoStack.push(null)
        undoGroup: ->
            while true
                let undo = @undoStack.pop()
                if undo?
                    let [x, y, v] = undo
                    @set(x, y, v, true)
                else
                    return

        domainSize: (n) -> bitSum(n, @boardWidth)
        firstInDomain: (n) -> firstOne(n, @boardWidth)
        domain: (n) -> allOnes(n, @boardWidth)

        cellIndex: (x, y) -> y * @boardWidth + x
        cellCord: (i) ->
            let x = i % @boardWidth
            let y = (i - x) / @boardWidth
            return [x, y]
        get: (x, y) -> @cells[@cellIndex(x, y)]
        set: (x, y, v, undo = false) ->
            let cell = @get(x, y)
            let preDomainSize = @domainSize(cell)
            let postDomainSize = @domainSize(v)
            @netDomain += postDomainSize - preDomainSize
            if not undo
                @pushUndo([x, y, cell])
            @cells[@cellIndex(x, y)] = v

        removeDomain: (x, y, v) ->
            let cell = @get(x, y)
            let preNetDomainSize = @netDomain
            cell = disableBit(cell, v)
            @set(x, y, cell)
            let domainSize = @domainSize(cell)
            if domainSize is 0
                return false
            else if domainSize is 1 and preNetDomainSize > @netDomain
                let determinedValue = @firstInDomain(cell)
                return @setAndUpdate(x, y, determinedValue)
            else
                return true
        minCord: ->
            let mini = 0
            let min = Infinity
            for i in range(@area)
                let curr = @domainSize(@cells[i])
                if curr > 1 and curr < min
                    min = curr
                    mini = i
            return @cellCord(mini)
        setAndUpdate: (x, y, v) ->
            @set(x, y, 1 << v)
            # Row
            for xi in range(@boardWidth)
                if xi isnt x
                    if not @removeDomain(xi, y, v)
                        return false
            # Column
            for yi in range(@boardWidth)
                if yi isnt y
                    if not @removeDomain(x, yi, v)
                        return false
            # Block
            let blockX = x - (x % @blockWidth)
            let blockY = y - (y % @blockWidth)
            for dx in range(@blockWidth)
                for dy in range(@blockWidth)
                    let xi = blockX + dx
                    let yi = blockY + dy
                    if xi isnt x and yi isnt y
                        if not @removeDomain(xi, yi, v)
                            return false
            return true
        solve: ->
            let [x, y] = @minCord()
            let cell = @get(x, y)
            let domain = @domain(cell)
            for value in domain
                @startUndoGroup()
                if @setAndUpdate(x, y, value)
                    if (@netDomain is @area) or @solve()
                        return true
                @undoGroup()
            return false

        displayValue: (x, y, count) ->
            let cell = @get(x, y)
            if count
                return @domainSize(cell)
            else
                if @domainSize(cell) is 1
                    return @firstInDomain(cell) + 1
                else
                    return '-'
        print: (count) ->
            for y in range(@boardWidth)
                if (y % @blockWidth) is 0 and y isnt 0
                    console.log(..)
                        [' ' for i in range(@boardWidth + @blockWidth - 1)].join(' ')
                let row = []
                    for x in range(@boardWidth)
                        if (x % @blockWidth) is 0 and x isnt 0
                            ' '
                        @displayValue(x, y, count)
                console.log(row.join(' '))

    parse: (boardString) ->
        let cells = []
            for line in boardString.split('\n')
                for cell in line.split(' ')
                    cell
        let boardWidth = Math.sqrt(cells.length)
        let blockWidth = Math.sqrt(boardWidth)
        let board = new Board(blockWidth)
        for cellStr, i in cells
            let cell = parseInt(cellStr)
            if isNaN(cell)
                continue
            let [x, y] = board.cellCord(i)
            board.setAndUpdate(x, y, cell - 1)
        return board

    test: ->
        console.time('solved')
        let board = Board.parse(..)
            ""
                - - - 7 - - - - -
                1 - - - - - - - -
                - - - 4 3 - 2 - -
                - - - - - - - - 6
                - - - 5 - 9 - - -
                - - - - - - 4 1 8
                - - - - 8 1 - - -
                - - 2 - - - - 5 -
                - 4 - - - - 3 - -
        let solved = board.solve()
        console.timeEnd('solved')
        if solved
            console.log()
            console.log('Solution: ')
            board.print(false)